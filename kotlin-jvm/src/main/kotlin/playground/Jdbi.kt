@file:Suppress("PackageDirectoryMismatch")

package playground.jdbi

import org.jdbi.v3.core.Jdbi
import org.jdbi.v3.core.extension.ExtensionCallback
import org.jdbi.v3.core.extension.ExtensionConsumer
import org.jdbi.v3.sqlobject.customizer.Bind
import org.jdbi.v3.sqlobject.customizer.BindBean
import org.jdbi.v3.sqlobject.statement.SqlQuery
import org.jdbi.v3.sqlobject.statement.SqlUpdate
import playground.shouldBe

/**
 * Jdbi provides convenient, idiomatic access to relational data
 * - [GitHub](https://github.com/jdbi/jdbi)
 * - [Official Website](https://jdbi.org/)
 */

private val testUser by lazy { User(1L, "Derrek") }
private val testOrders by lazy {
    listOf(
        Order(1L, "T-shirt", 50, 1L),
        Order(2L, "Jeans", 100, 1L),
        Order(3L, "Hat", 35, 1L)
    )
}

fun main() {
    println()
    println("Jdbi - Kotlin SQL Framework")
    val jdbi = Jdbi.create("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1")
    jdbi.installPlugins()

    insertData(jdbi)
    readData(jdbi)
    deleteData(jdbi)
}

fun insertData(jdbi: Jdbi) {
    jdbi.useExtension(UserDAO::class.java, ExtensionConsumer { dao ->
        dao.createTable()
        dao.createUser(testUser)
    })

    jdbi.useExtension(OrderDAO::class.java, ExtensionConsumer { dao ->
        dao.createTable()
        testOrders.forEach {
            dao.createOrder(it)
        }
    })

    println("Data inserted successfully")
}

fun readData(jdbi: Jdbi) {
    val user = jdbi.withExtension(UserDAO::class.java, ExtensionCallback {
        it.findByName("Derrek")
    })

    user shouldBe testUser

    val orders = jdbi.withExtension(OrderDAO::class.java, ExtensionCallback {
        it.findOrdersByUser(user.userId)
    })

    orders shouldBe testOrders

    println("Data fetched successfully")
}

fun deleteData(jdbi: Jdbi) {
    val orders = jdbi.withExtension(OrderDAO::class.java, ExtensionCallback { dao ->
        dao.deleteAll()
        dao.findAll()
    })

    orders shouldBe emptyList()

    val users = jdbi.withExtension(UserDAO::class.java, ExtensionCallback { dao ->
        dao.deleteAll()
        dao.findAll()
    })

    users shouldBe emptyList()

    println("Data removed successfully")
}

data class User(
    val userId: Long,
    val userName: String
)

data class Order(
    val orderId: Long,
    val product: String,
    val price: Int,
    val orderedBy: Long
)

interface UserDAO {
    @SqlUpdate(
        """
            CREATE TABLE IF NOT EXISTS user(
                user_id bigint GENERATED BY DEFAULT AS IDENTITY
                    PRIMARY KEY,
                user_name varchar
            )
        """
    )
    fun createTable()

    @SqlUpdate("INSERT INTO user(user_name) VALUES (:userName)")
    fun createUser(@BindBean user: User)

    @SqlQuery("SELECT * FROM user")
    fun findAll(): List<User>

    @SqlQuery("SELECT * FROM user WHERE user_name = :name")
    fun findByName(@Bind("name") name: String): User

    @SqlUpdate("DELETE FROM user")
    fun deleteAll()
}

interface OrderDAO {
    @SqlUpdate(
        """
            CREATE TABLE IF NOT EXISTS orders(
                order_id bigint GENERATED BY DEFAULT AS IDENTITY
                    PRIMARY KEY,
                product varchar,
                price int,
                ordered_by bigint
                    CONSTRAINT fk_ordered_by_id
                    REFERENCES user(user_id)
            )
        """
    )
    fun createTable()

    @SqlUpdate(
        """
        INSERT INTO ORDERS(product, price, ordered_by)
            VALUES (:product, :price, :orderedBy)
        """
    )
    fun createOrder(@BindBean order: Order)

    @SqlQuery("SELECT * FROM orders WHERE ordered_by = :orderedBy")
    fun findOrdersByUser(@Bind("orderedBy") orderedBy: Long): List<Order>

    @SqlUpdate("DELETE FROM orders")
    fun deleteAll()

    @SqlQuery("SELECT * FROM orders")
    fun findAll(): List<Order>
}
